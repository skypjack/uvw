<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::stream_handle&lt; T, U &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uvw
   &#160;<span id="projectnumber">2.12.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvw_1_1stream__handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uvw::stream_handle&lt; T, U &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The stream handle.  
 <a href="classuvw_1_1stream__handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream_8h_source.html">stream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::stream_handle&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1stream__handle__inherit__graph.png" border="0" usemap="#auvw_1_1stream__handle_3_01T_00_01U_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="auvw_1_1stream__handle_3_01T_00_01U_01_4_inherit__map" id="auvw_1_1stream__handle_3_01T_00_01U_01_4_inherit__map">
<area shape="rect" title="The stream handle." alt="" coords="87,244,223,285"/>
<area shape="rect" href="classuvw_1_1handle.html" title="Handle base class." alt="" coords="87,169,224,196"/>
<area shape="rect" href="classuvw_1_1resource.html" title="Common class for almost all the resources available in uvw." alt="" coords="81,95,230,121"/>
<area shape="rect" href="classuvw_1_1underlying__type.html" title="Wrapper class for underlying types." alt="" coords="5,5,148,47"/>
<area shape="rect" href="classuvw_1_1emitter.html" title="Event emitter base class." alt="" coords="173,13,295,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::stream_handle&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1stream__handle__coll__graph.png" border="0" usemap="#auvw_1_1stream__handle_3_01T_00_01U_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="auvw_1_1stream__handle_3_01T_00_01U_01_4_coll__map" id="auvw_1_1stream__handle_3_01T_00_01U_01_4_coll__map">
<area shape="rect" title="The stream handle." alt="" coords="87,244,223,285"/>
<area shape="rect" href="classuvw_1_1handle.html" title="Handle base class." alt="" coords="87,169,224,196"/>
<area shape="rect" href="classuvw_1_1resource.html" title="Common class for almost all the resources available in uvw." alt="" coords="81,95,230,121"/>
<area shape="rect" href="classuvw_1_1underlying__type.html" title="Wrapper class for underlying types." alt="" coords="5,5,148,47"/>
<area shape="rect" href="classuvw_1_1emitter.html" title="Event emitter base class." alt="" coords="173,13,295,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5ae5022dbd4bcead8ed09eaa80fff14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ab5ae5022dbd4bcead8ed09eaa80fff14">shutdown</a> ()</td></tr>
<tr class="memdesc:ab5ae5022dbd4bcead8ed09eaa80fff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdowns the outgoing (write) side of a duplex stream.  <a href="classuvw_1_1stream__handle.html#ab5ae5022dbd4bcead8ed09eaa80fff14">More...</a><br /></td></tr>
<tr class="separator:ab5ae5022dbd4bcead8ed09eaa80fff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a138edb649a472a312e9f1f441766d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a03a138edb649a472a312e9f1f441766d">listen</a> (int backlog=DEFAULT_BACKLOG)</td></tr>
<tr class="memdesc:a03a138edb649a472a312e9f1f441766d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts listening for incoming connections.  <a href="classuvw_1_1stream__handle.html#a03a138edb649a472a312e9f1f441766d">More...</a><br /></td></tr>
<tr class="separator:a03a138edb649a472a312e9f1f441766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f362916ac100b09b01b7c717a1cd9f9"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a1f362916ac100b09b01b7c717a1cd9f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a1f362916ac100b09b01b7c717a1cd9f9">accept</a> (S &amp;ref)</td></tr>
<tr class="memdesc:a1f362916ac100b09b01b7c717a1cd9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts incoming connections.  <a href="classuvw_1_1stream__handle.html#a1f362916ac100b09b01b7c717a1cd9f9">More...</a><br /></td></tr>
<tr class="separator:a1f362916ac100b09b01b7c717a1cd9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b855df34bb219fd5402dc792588161e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a4b855df34bb219fd5402dc792588161e">read</a> ()</td></tr>
<tr class="memdesc:a4b855df34bb219fd5402dc792588161e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts reading data from an incoming stream.  <a href="classuvw_1_1stream__handle.html#a4b855df34bb219fd5402dc792588161e">More...</a><br /></td></tr>
<tr class="separator:a4b855df34bb219fd5402dc792588161e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfebb35f778cb3f4f0299ff75a93cae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#acfebb35f778cb3f4f0299ff75a93cae6">stop</a> ()</td></tr>
<tr class="memdesc:acfebb35f778cb3f4f0299ff75a93cae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops reading data from the stream.  <a href="classuvw_1_1stream__handle.html#acfebb35f778cb3f4f0299ff75a93cae6">More...</a><br /></td></tr>
<tr class="separator:acfebb35f778cb3f4f0299ff75a93cae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1c1a2b0efd00e1d111028465123353"><td class="memTemplParams" colspan="2">template&lt;typename Deleter &gt; </td></tr>
<tr class="memitem:a5b1c1a2b0efd00e1d111028465123353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a5b1c1a2b0efd00e1d111028465123353">write</a> (std::unique_ptr&lt; char[], Deleter &gt; <a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a5b1c1a2b0efd00e1d111028465123353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <a href="classuvw_1_1stream__handle.html#a5b1c1a2b0efd00e1d111028465123353">More...</a><br /></td></tr>
<tr class="separator:a5b1c1a2b0efd00e1d111028465123353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f1d724e22cb9aad346c8a9f7884f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ab1f1d724e22cb9aad346c8a9f7884f91">write</a> (char *<a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:ab1f1d724e22cb9aad346c8a9f7884f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <a href="classuvw_1_1stream__handle.html#ab1f1d724e22cb9aad346c8a9f7884f91">More...</a><br /></td></tr>
<tr class="separator:ab1f1d724e22cb9aad346c8a9f7884f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7898d65c6dc67c05edba3bf2290ac189"><td class="memTemplParams" colspan="2">template&lt;typename S , typename Deleter &gt; </td></tr>
<tr class="memitem:a7898d65c6dc67c05edba3bf2290ac189"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a7898d65c6dc67c05edba3bf2290ac189">write</a> (S &amp;send, std::unique_ptr&lt; char[], Deleter &gt; <a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a7898d65c6dc67c05edba3bf2290ac189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <a href="classuvw_1_1stream__handle.html#a7898d65c6dc67c05edba3bf2290ac189">More...</a><br /></td></tr>
<tr class="separator:a7898d65c6dc67c05edba3bf2290ac189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ff8cca5ce28a0714b0dcda5064a22d"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a34ff8cca5ce28a0714b0dcda5064a22d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a34ff8cca5ce28a0714b0dcda5064a22d">write</a> (S &amp;send, char *<a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a34ff8cca5ce28a0714b0dcda5064a22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <a href="classuvw_1_1stream__handle.html#a34ff8cca5ce28a0714b0dcda5064a22d">More...</a><br /></td></tr>
<tr class="separator:a34ff8cca5ce28a0714b0dcda5064a22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f6e2927e160d2d658bf71614bc34e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a043f6e2927e160d2d658bf71614bc34e">tryWrite</a> (std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a043f6e2927e160d2d658bf71614bc34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="classuvw_1_1stream__handle.html#a043f6e2927e160d2d658bf71614bc34e">More...</a><br /></td></tr>
<tr class="separator:a043f6e2927e160d2d658bf71614bc34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890f1598cb31a6a9cb3a3d42f54e1390"><td class="memTemplParams" colspan="2">template&lt;typename V , typename W &gt; </td></tr>
<tr class="memitem:a890f1598cb31a6a9cb3a3d42f54e1390"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a890f1598cb31a6a9cb3a3d42f54e1390">tryWrite</a> (std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len, <a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;send)</td></tr>
<tr class="memdesc:a890f1598cb31a6a9cb3a3d42f54e1390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="classuvw_1_1stream__handle.html#a890f1598cb31a6a9cb3a3d42f54e1390">More...</a><br /></td></tr>
<tr class="separator:a890f1598cb31a6a9cb3a3d42f54e1390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b67baf6e564f0e1b631f3983d7de50d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a6b67baf6e564f0e1b631f3983d7de50d">tryWrite</a> (char *<a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a6b67baf6e564f0e1b631f3983d7de50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="classuvw_1_1stream__handle.html#a6b67baf6e564f0e1b631f3983d7de50d">More...</a><br /></td></tr>
<tr class="separator:a6b67baf6e564f0e1b631f3983d7de50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceb4770287617cedad6da328be986f7"><td class="memTemplParams" colspan="2">template&lt;typename V , typename W &gt; </td></tr>
<tr class="memitem:afceb4770287617cedad6da328be986f7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#afceb4770287617cedad6da328be986f7">tryWrite</a> (char *<a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a>, unsigned int len, <a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;send)</td></tr>
<tr class="memdesc:afceb4770287617cedad6da328be986f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <a href="classuvw_1_1stream__handle.html#afceb4770287617cedad6da328be986f7">More...</a><br /></td></tr>
<tr class="separator:afceb4770287617cedad6da328be986f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1268dee597e92a50e96605c6e068c94f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a1268dee597e92a50e96605c6e068c94f">readable</a> () const noexcept</td></tr>
<tr class="memdesc:a1268dee597e92a50e96605c6e068c94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is readable.  <a href="classuvw_1_1stream__handle.html#a1268dee597e92a50e96605c6e068c94f">More...</a><br /></td></tr>
<tr class="separator:a1268dee597e92a50e96605c6e068c94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816ee2f08b3ccb23bbed47be840f681b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a816ee2f08b3ccb23bbed47be840f681b">writable</a> () const noexcept</td></tr>
<tr class="memdesc:a816ee2f08b3ccb23bbed47be840f681b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is writable.  <a href="classuvw_1_1stream__handle.html#a816ee2f08b3ccb23bbed47be840f681b">More...</a><br /></td></tr>
<tr class="separator:a816ee2f08b3ccb23bbed47be840f681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8be0961312ab659a156018f4faa534"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a2a8be0961312ab659a156018f4faa534">blocking</a> (bool enable=false)</td></tr>
<tr class="memdesc:a2a8be0961312ab659a156018f4faa534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables blocking mode for a stream.  <a href="classuvw_1_1stream__handle.html#a2a8be0961312ab659a156018f4faa534">More...</a><br /></td></tr>
<tr class="separator:a2a8be0961312ab659a156018f4faa534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74048a146605dcb78480f5140e2deab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ae74048a146605dcb78480f5140e2deab">writeQueueSize</a> () const noexcept</td></tr>
<tr class="memdesc:ae74048a146605dcb78480f5140e2deab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of queued bytes waiting to be sent.  <a href="classuvw_1_1stream__handle.html#ae74048a146605dcb78480f5140e2deab">More...</a><br /></td></tr>
<tr class="separator:ae74048a146605dcb78480f5140e2deab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1handle.html">uvw::handle&lt; T, U &gt;</a></td></tr>
<tr class="memitem:af39ee97ba1e4f1da9e3f60b3dd3d415a inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a9e28e1855691dd1af105626ed11f3ac4">handle_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#af39ee97ba1e4f1da9e3f60b3dd3d415a">category</a> () const noexcept</td></tr>
<tr class="memdesc:af39ee97ba1e4f1da9e3f60b3dd3d415a inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <a href="classuvw_1_1handle.html#af39ee97ba1e4f1da9e3f60b3dd3d415a">More...</a><br /></td></tr>
<tr class="separator:af39ee97ba1e4f1da9e3f60b3dd3d415a inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900bad6060e3c93f08aec3d9db30cc7e inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#aa405fd6cd2fbafa5ced4b2092e389785">handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a900bad6060e3c93f08aec3d9db30cc7e">type</a> () const noexcept</td></tr>
<tr class="memdesc:a900bad6060e3c93f08aec3d9db30cc7e inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <a href="classuvw_1_1handle.html#a900bad6060e3c93f08aec3d9db30cc7e">More...</a><br /></td></tr>
<tr class="separator:a900bad6060e3c93f08aec3d9db30cc7e inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3889a8f8deefba4dbc593054128323 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a0e3889a8f8deefba4dbc593054128323">active</a> () const noexcept</td></tr>
<tr class="memdesc:a0e3889a8f8deefba4dbc593054128323 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <a href="classuvw_1_1handle.html#a0e3889a8f8deefba4dbc593054128323">More...</a><br /></td></tr>
<tr class="separator:a0e3889a8f8deefba4dbc593054128323 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534a0ee7f8382a80a50f55f97b741482 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a534a0ee7f8382a80a50f55f97b741482">closing</a> () const noexcept</td></tr>
<tr class="memdesc:a534a0ee7f8382a80a50f55f97b741482 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <a href="classuvw_1_1handle.html#a534a0ee7f8382a80a50f55f97b741482">More...</a><br /></td></tr>
<tr class="separator:a534a0ee7f8382a80a50f55f97b741482 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c28fea5eac42898607fd15f92addd46 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a1c28fea5eac42898607fd15f92addd46">close</a> () noexcept</td></tr>
<tr class="memdesc:a1c28fea5eac42898607fd15f92addd46 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request handle to be closed.  <a href="classuvw_1_1handle.html#a1c28fea5eac42898607fd15f92addd46">More...</a><br /></td></tr>
<tr class="separator:a1c28fea5eac42898607fd15f92addd46 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89390a42e8921ce182f07e5bd79dbbb9 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a89390a42e8921ce182f07e5bd79dbbb9">reference</a> () noexcept</td></tr>
<tr class="memdesc:a89390a42e8921ce182f07e5bd79dbbb9 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference the given handle.  <a href="classuvw_1_1handle.html#a89390a42e8921ce182f07e5bd79dbbb9">More...</a><br /></td></tr>
<tr class="separator:a89390a42e8921ce182f07e5bd79dbbb9 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce483e2c259229eda267715e2bb7843 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a2ce483e2c259229eda267715e2bb7843">unreference</a> () noexcept</td></tr>
<tr class="memdesc:a2ce483e2c259229eda267715e2bb7843 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference the given handle.  <a href="classuvw_1_1handle.html#a2ce483e2c259229eda267715e2bb7843">More...</a><br /></td></tr>
<tr class="separator:a2ce483e2c259229eda267715e2bb7843 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a7ff6b3cd25e0b2140d7fa90422a8d inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a53a7ff6b3cd25e0b2140d7fa90422a8d">referenced</a> () const noexcept</td></tr>
<tr class="memdesc:a53a7ff6b3cd25e0b2140d7fa90422a8d inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <a href="classuvw_1_1handle.html#a53a7ff6b3cd25e0b2140d7fa90422a8d">More...</a><br /></td></tr>
<tr class="separator:a53a7ff6b3cd25e0b2140d7fa90422a8d inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5521f7dd044bda148aeae4bc44aa4ccd inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a5521f7dd044bda148aeae4bc44aa4ccd">size</a> () const noexcept</td></tr>
<tr class="memdesc:a5521f7dd044bda148aeae4bc44aa4ccd inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying handle type.  <a href="classuvw_1_1handle.html#a5521f7dd044bda148aeae4bc44aa4ccd">More...</a><br /></td></tr>
<tr class="separator:a5521f7dd044bda148aeae4bc44aa4ccd inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b703880f625e646320e339557922a6b inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a7b703880f625e646320e339557922a6b">sendBufferSize</a> ()</td></tr>
<tr class="memdesc:a7b703880f625e646320e339557922a6b inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the send buffer used for the socket.  <a href="classuvw_1_1handle.html#a7b703880f625e646320e339557922a6b">More...</a><br /></td></tr>
<tr class="separator:a7b703880f625e646320e339557922a6b inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad64fc8c00a614fe1d1fa16a9b1c375 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a9ad64fc8c00a614fe1d1fa16a9b1c375">sendBufferSize</a> (int value)</td></tr>
<tr class="memdesc:a9ad64fc8c00a614fe1d1fa16a9b1c375 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the send buffer used for the socket.  <a href="classuvw_1_1handle.html#a9ad64fc8c00a614fe1d1fa16a9b1c375">More...</a><br /></td></tr>
<tr class="separator:a9ad64fc8c00a614fe1d1fa16a9b1c375 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4dd5c2f9ff083f763edb03f111c2c4 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a3e4dd5c2f9ff083f763edb03f111c2c4">recvBufferSize</a> ()</td></tr>
<tr class="memdesc:a3e4dd5c2f9ff083f763edb03f111c2c4 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the receive buffer used for the socket.  <a href="classuvw_1_1handle.html#a3e4dd5c2f9ff083f763edb03f111c2c4">More...</a><br /></td></tr>
<tr class="separator:a3e4dd5c2f9ff083f763edb03f111c2c4 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f8c72d39f726f06cd4b50c689cc82d inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a01f8c72d39f726f06cd4b50c689cc82d">recvBufferSize</a> (int value)</td></tr>
<tr class="memdesc:a01f8c72d39f726f06cd4b50c689cc82d inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the receive buffer used for the socket.  <a href="classuvw_1_1handle.html#a01f8c72d39f726f06cd4b50c689cc82d">More...</a><br /></td></tr>
<tr class="separator:a01f8c72d39f726f06cd4b50c689cc82d inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcf3c65100634da3c3378c491aacc17 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a1a4f79e341b89257a11403ee0739f2b4">os_file_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#aefcf3c65100634da3c3378c491aacc17">fd</a> () const</td></tr>
<tr class="memdesc:aefcf3c65100634da3c3378c491aacc17 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the platform dependent file descriptor equivalent.  <a href="classuvw_1_1handle.html#aefcf3c65100634da3c3378c491aacc17">More...</a><br /></td></tr>
<tr class="separator:aefcf3c65100634da3c3378c491aacc17 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1resource.html">uvw::resource&lt; T, U &gt;</a></td></tr>
<tr class="memitem:aa46be2a52bcd0b2e7fa664e75261a13f inherit pub_methods_classuvw_1_1resource"><td class="memTemplParams" colspan="2">template&lt;typename R  = void&gt; </td></tr>
<tr class="memitem:aa46be2a52bcd0b2e7fa664e75261a13f inherit pub_methods_classuvw_1_1resource"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">data</a> () const</td></tr>
<tr class="memdesc:aa46be2a52bcd0b2e7fa664e75261a13f inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets user-defined data. <code>uvw</code> won't use this field in any case.  <a href="classuvw_1_1resource.html#aa46be2a52bcd0b2e7fa664e75261a13f">More...</a><br /></td></tr>
<tr class="separator:aa46be2a52bcd0b2e7fa664e75261a13f inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b102640a7705727b45c7b1149935f6 inherit pub_methods_classuvw_1_1resource"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#a65b102640a7705727b45c7b1149935f6">data</a> (std::shared_ptr&lt; void &gt; uData)</td></tr>
<tr class="memdesc:a65b102640a7705727b45c7b1149935f6 inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arbitrary data. <code>uvw</code> won't use this field in any case.  <a href="classuvw_1_1resource.html#a65b102640a7705727b45c7b1149935f6">More...</a><br /></td></tr>
<tr class="separator:a65b102640a7705727b45c7b1149935f6 inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1underlying__type"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1underlying__type')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1underlying__type.html">uvw::underlying_type&lt; T, U &gt;</a></td></tr>
<tr class="memitem:ab7cc17fb1bf63082a726e0199a6d1a58 inherit pub_methods_classuvw_1_1underlying__type"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvw_1_1Loop.html">Loop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1underlying__type.html#ab7cc17fb1bf63082a726e0199a6d1a58">loop</a> () const noexcept</td></tr>
<tr class="memdesc:ab7cc17fb1bf63082a726e0199a6d1a58 inherit pub_methods_classuvw_1_1underlying__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the loop from which the resource was originated.  <a href="classuvw_1_1underlying__type.html#ab7cc17fb1bf63082a726e0199a6d1a58">More...</a><br /></td></tr>
<tr class="separator:ab7cc17fb1bf63082a726e0199a6d1a58 inherit pub_methods_classuvw_1_1underlying__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d327fb809ce0ecc12f7e4f55f6f396 inherit pub_methods_classuvw_1_1underlying__type"><td class="memItemLeft" align="right" valign="top">const U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1underlying__type.html#a85d327fb809ce0ecc12f7e4f55f6f396">raw</a> () const noexcept</td></tr>
<tr class="memdesc:a85d327fb809ce0ecc12f7e4f55f6f396 inherit pub_methods_classuvw_1_1underlying__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1underlying__type.html#a85d327fb809ce0ecc12f7e4f55f6f396">More...</a><br /></td></tr>
<tr class="separator:a85d327fb809ce0ecc12f7e4f55f6f396 inherit pub_methods_classuvw_1_1underlying__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf39b5478bf890a3eb6c7630ca8ba7b5 inherit pub_methods_classuvw_1_1underlying__type"><td class="memItemLeft" align="right" valign="top">U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1underlying__type.html#abf39b5478bf890a3eb6c7630ca8ba7b5">raw</a> () noexcept</td></tr>
<tr class="memdesc:abf39b5478bf890a3eb6c7630ca8ba7b5 inherit pub_methods_classuvw_1_1underlying__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <a href="classuvw_1_1underlying__type.html#abf39b5478bf890a3eb6c7630ca8ba7b5">More...</a><br /></td></tr>
<tr class="separator:abf39b5478bf890a3eb6c7630ca8ba7b5 inherit pub_methods_classuvw_1_1underlying__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1emitter.html">uvw::emitter&lt; T &gt;</a></td></tr>
<tr class="memitem:ae22cbfff2540c5f72c2e9266801ed3bd inherit pub_methods_classuvw_1_1emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:ae22cbfff2540c5f72c2e9266801ed3bd inherit pub_methods_classuvw_1_1emitter"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1emitter_1_1connection.html">connection</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ae22cbfff2540c5f72c2e9266801ed3bd">on</a> (listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:ae22cbfff2540c5f72c2e9266801ed3bd inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <a href="classuvw_1_1emitter.html#ae22cbfff2540c5f72c2e9266801ed3bd">More...</a><br /></td></tr>
<tr class="separator:ae22cbfff2540c5f72c2e9266801ed3bd inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b83cee911d13a92348b885091c3a8a inherit pub_methods_classuvw_1_1emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a37b83cee911d13a92348b885091c3a8a inherit pub_methods_classuvw_1_1emitter"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1emitter_1_1connection.html">connection</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#a37b83cee911d13a92348b885091c3a8a">once</a> (listener&lt; E &gt; f)</td></tr>
<tr class="memdesc:a37b83cee911d13a92348b885091c3a8a inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a short-lived listener with the event emitter.  <a href="classuvw_1_1emitter.html#a37b83cee911d13a92348b885091c3a8a">More...</a><br /></td></tr>
<tr class="separator:a37b83cee911d13a92348b885091c3a8a inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9464b47e9f7d1420c267d2d3e06cf148 inherit pub_methods_classuvw_1_1emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a9464b47e9f7d1420c267d2d3e06cf148 inherit pub_methods_classuvw_1_1emitter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#a9464b47e9f7d1420c267d2d3e06cf148">erase</a> (<a class="el" href="structuvw_1_1emitter_1_1connection.html">connection</a>&lt; E &gt; conn) noexcept</td></tr>
<tr class="memdesc:a9464b47e9f7d1420c267d2d3e06cf148 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects a listener from the event emitter.  <a href="classuvw_1_1emitter.html#a9464b47e9f7d1420c267d2d3e06cf148">More...</a><br /></td></tr>
<tr class="separator:a9464b47e9f7d1420c267d2d3e06cf148 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa660fcb4d6b7b18792da89dfadd5f5 inherit pub_methods_classuvw_1_1emitter"><td class="memTemplParams" colspan="2"><a id="affa660fcb4d6b7b18792da89dfadd5f5"></a>
template&lt;typename E &gt; </td></tr>
<tr class="memitem:affa660fcb4d6b7b18792da89dfadd5f5 inherit pub_methods_classuvw_1_1emitter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#affa660fcb4d6b7b18792da89dfadd5f5">clear</a> () noexcept</td></tr>
<tr class="memdesc:affa660fcb4d6b7b18792da89dfadd5f5 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners for the given event type. <br /></td></tr>
<tr class="separator:affa660fcb4d6b7b18792da89dfadd5f5 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac404a612b18524d078f537f83535fb64 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="ac404a612b18524d078f537f83535fb64"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ac404a612b18524d078f537f83535fb64">clear</a> () noexcept</td></tr>
<tr class="memdesc:ac404a612b18524d078f537f83535fb64 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all the listeners. <br /></td></tr>
<tr class="separator:ac404a612b18524d078f537f83535fb64 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8694584f64186b2e69524df05f6140ab inherit pub_methods_classuvw_1_1emitter"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a8694584f64186b2e69524df05f6140ab inherit pub_methods_classuvw_1_1emitter"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#a8694584f64186b2e69524df05f6140ab">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a8694584f64186b2e69524df05f6140ab inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered for the specific event.  <a href="classuvw_1_1emitter.html#a8694584f64186b2e69524df05f6140ab">More...</a><br /></td></tr>
<tr class="separator:a8694584f64186b2e69524df05f6140ab inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d9b202940a46dc1c4e6a6a0ff6a699 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#a97d9b202940a46dc1c4e6a6a0ff6a699">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a97d9b202940a46dc1c4e6a6a0ff6a699 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are listeners registered with the event emitter.  <a href="classuvw_1_1emitter.html#a97d9b202940a46dc1c4e6a6a0ff6a699">More...</a><br /></td></tr>
<tr class="separator:a97d9b202940a46dc1c4e6a6a0ff6a699 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classuvw_1_1underlying__type"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classuvw_1_1underlying__type')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classuvw_1_1underlying__type.html">uvw::underlying_type&lt; T, U &gt;</a></td></tr>
<tr class="memitem:aa0d2f1cfdd703944a38b8d2b71cfa059 inherit pub_static_methods_classuvw_1_1underlying__type"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa0d2f1cfdd703944a38b8d2b71cfa059 inherit pub_static_methods_classuvw_1_1underlying__type"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1underlying__type.html#aa0d2f1cfdd703944a38b8d2b71cfa059">create</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aa0d2f1cfdd703944a38b8d2b71cfa059 inherit pub_static_methods_classuvw_1_1underlying__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new resource of the given type.  <a href="classuvw_1_1underlying__type.html#aa0d2f1cfdd703944a38b8d2b71cfa059">More...</a><br /></td></tr>
<tr class="separator:aa0d2f1cfdd703944a38b8d2b71cfa059 inherit pub_static_methods_classuvw_1_1underlying__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename U&gt;<br />
class uvw::stream_handle&lt; T, U &gt;</h3>

<p>The stream handle. </p>
<p>Stream handles provide an abstraction of a duplex communication channel. The stream handle is an intermediate type, <code>uvw</code> provides three stream implementations: <a class="el" href="classuvw_1_1TCPHandle.html" title="The TCPHandle handle.">TCPHandle</a>, <a class="el" href="classuvw_1_1PipeHandle.html" title="The PipeHandle handle.">PipeHandle</a> and <a class="el" href="classuvw_1_1TTYHandle.html" title="The TTYHandle handle.">TTYHandle</a>. </p>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00089">89</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f362916ac100b09b01b7c717a1cd9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f362916ac100b09b01b7c717a1cd9f9">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts incoming connections. </p>
<p>This call is used in conjunction with <code><a class="el" href="classuvw_1_1stream__handle.html#a03a138edb649a472a312e9f1f441766d" title="Starts listening for incoming connections.">listen()</a></code> to accept incoming connections. Call this function after receiving a listen event to accept the connection. Before calling this function, the submitted handle must be initialized.<br  />
 An error event will be emitted in case of errors.</p>
<p>When the listen event is emitted it is guaranteed that this function will complete successfully the first time. If you attempt to use it more than once, it may fail.<br  />
 It is suggested to only call this function once per listen event.</p>
<dl class="section note"><dt>Note</dt><dd>Both the handles must be running on the same loop.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>An initialized handle to be used to accept the connection. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00181">181</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a2a8be0961312ab659a156018f4faa534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8be0961312ab659a156018f4faa534">&#9670;&nbsp;</a></span>blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables blocking mode for a stream. </p>
<p>When blocking mode is enabled all writes complete synchronously. The interface remains unchanged otherwise, e.g. completion or failure of the operation will still be reported through events which are emitted asynchronously.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_stream_set_blocking">documentation</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable blocking mode, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00439">439</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a03a138edb649a472a312e9f1f441766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a138edb649a472a312e9f1f441766d">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em> = <code>DEFAULT_BACKLOG</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts listening for incoming connections. </p>
<p>When a new incoming connection is received, a listen event is emitted.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>Indicates the number of connections the kernel might queue, same as listen(2). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00157">157</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a4b855df34bb219fd5402dc792588161e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b855df34bb219fd5402dc792588161e">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts reading data from an incoming stream. </p>
<p>A data event will be emitted several times until there is no more data to read or <code><a class="el" href="classuvw_1_1stream__handle.html#acfebb35f778cb3f4f0299ff75a93cae6" title="Stops reading data from the stream.">stop()</a></code> is called.<br  />
 An end event will be emitted when there is no more data to read. </p>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00192">192</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a1268dee597e92a50e96605c6e068c94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1268dee597e92a50e96605c6e068c94f">&#9670;&nbsp;</a></span>readable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::readable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream is readable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the stream is readable, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00412">412</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="ab5ae5022dbd4bcead8ed09eaa80fff14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ae5022dbd4bcead8ed09eaa80fff14">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdowns the outgoing (write) side of a duplex stream. </p>
<p>It waits for pending write requests to complete. The handle should refer to a initialized stream.<br  />
 A shutdown event will be emitted after shutdown is complete. </p>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00136">136</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="acfebb35f778cb3f4f0299ff75a93cae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfebb35f778cb3f4f0299ff75a93cae6">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops reading data from the stream. </p>
<p>This function is idempotent and may be safely called on a stopped stream. </p>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00201">201</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a6b67baf6e564f0e1b631f3983d7de50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b67baf6e564f0e1b631f3983d7de50d">&#9670;&nbsp;</a></span>tryWrite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::tryWrite </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code><a class="el" href="classuvw_1_1stream__handle.html#a5b1c1a2b0efd00e1d111028465123353" title="Writes data to the stream.">write()</a></code>, but wont queue a write request if it cant be completed immediately.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00372">372</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="afceb4770287617cedad6da328be986f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afceb4770287617cedad6da328be986f7">&#9670;&nbsp;</a></span>tryWrite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<div class="memtemplate">
template&lt;typename V , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::tryWrite </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code>tryWrite</code> for sending handles over a pipe.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
    <tr><td class="paramname">send</td><td>A valid handle suitable for the purpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00396">396</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a043f6e2927e160d2d658bf71614bc34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043f6e2927e160d2d658bf71614bc34e">&#9670;&nbsp;</a></span>tryWrite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::tryWrite </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code><a class="el" href="classuvw_1_1stream__handle.html#a5b1c1a2b0efd00e1d111028465123353" title="Writes data to the stream.">write()</a></code>, but wont queue a write request if it cant be completed immediately.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00325">325</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a890f1598cb31a6a9cb3a3d42f54e1390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890f1598cb31a6a9cb3a3d42f54e1390">&#9670;&nbsp;</a></span>tryWrite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<div class="memtemplate">
template&lt;typename V , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::tryWrite </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code>tryWrite</code> for sending handles over a pipe.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
    <tr><td class="paramname">send</td><td>A valid handle suitable for the purpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00349">349</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a816ee2f08b3ccb23bbed47be840f681b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816ee2f08b3ccb23bbed47be840f681b">&#9670;&nbsp;</a></span>writable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::writable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream is writable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the stream is writable, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00420">420</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="ab1f1d724e22cb9aad346c8a9f7884f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f1d724e22cb9aad346c8a9f7884f91">&#9670;&nbsp;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the stream. </p>
<p>Data are written in order. The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A write event will be emitted when the data have been written.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00241">241</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a34ff8cca5ce28a0714b0dcda5064a22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ff8cca5ce28a0714b0dcda5064a22d">&#9670;&nbsp;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended write function for sending handles over a pipe handle. </p>
<p>The pipe must be initialized with <code>ipc == true</code>.</p>
<p><code>send</code> must be a <a class="el" href="classuvw_1_1TCPHandle.html" title="The TCPHandle handle.">TCPHandle</a> or <a class="el" href="classuvw_1_1PipeHandle.html" title="The PipeHandle handle.">PipeHandle</a> handle, which is a server or a connection (listening or connected state). Bound sockets or pipes will be assumed to be servers.</p>
<p>The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A write event will be emitted when the data have been written.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The handle over which to write data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00303">303</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a7898d65c6dc67c05edba3bf2290ac189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7898d65c6dc67c05edba3bf2290ac189">&#9670;&nbsp;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<div class="memtemplate">
template&lt;typename S , typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[], Deleter &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended write function for sending handles over a pipe handle. </p>
<p>The pipe must be initialized with <code>ipc == true</code>.</p>
<p><code>send</code> must be a <a class="el" href="classuvw_1_1TCPHandle.html" title="The TCPHandle handle.">TCPHandle</a> or <a class="el" href="classuvw_1_1PipeHandle.html" title="The PipeHandle handle.">PipeHandle</a> handle, which is a server or a connection (listening or connected state). Bound sockets or pipes will be assumed to be servers.</p>
<p>The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A write event will be emitted when the data have been written.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The handle over which to write data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00272">272</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a5b1c1a2b0efd00e1d111028465123353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1c1a2b0efd00e1d111028465123353">&#9670;&nbsp;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<div class="memtemplate">
template&lt;typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[], Deleter &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the stream. </p>
<p>Data are written in order. The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A write event will be emitted when the data have been written.<br  />
 An error event will be emitted in case of errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00218">218</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="ae74048a146605dcb78480f5140e2deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74048a146605dcb78480f5140e2deab">&#9670;&nbsp;</a></span>writeQueueSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U &gt;::writeQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the amount of queued bytes waiting to be sent. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of queued bytes waiting to be sent. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00447">447</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="stream_8h_source.html">stream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
